---
title: "Normality in Collatz Conjecture"
author: "*230170678*"
date: "*2024-04-27*"
output: 
  html_document:
    css: styles.css
runtime: shiny
---

## Introduction

This application to exploring the Collatz Conjecture, also known as the "3n + 1 problem," through interactive visualizations. The application allows users to input a starting integer value and a multiplier, subsequently generating a sequence according to the Collatz rules. These sequences are visualized through sequence plots and quantile-quantile (Q-Q) plots to assess their distribution's normality compared to a theoretical normal distribution.

#### Research Questions:
1. **How does varying the initial value (n) affect the length and peak values of Collatz sequences generated by the application?**  
This question explores how changes in the starting number influence specific characteristics of the sequence, such as its length and the maximum values (peaks) it reaches. It can help understand how the choice of initial number impacts the complexity and behavior of the sequence.  
2. **Does the application of a multiplier to the starting number alter the normality of Collatz sequences as assessed through quantile-quantile plots and Shapiro-Wilk tests?**"    
This question focuses on the statistical analysis aspect, particularly looking at how multiplying the starting number affects the sequence's adherence to a normal distribution. This includes examining changes in p-values and the visual fit in Q-Q plots across different multipliers

The project uses several R packages:

-   **'shiny'**: Provides tools for building interactive web apps straight from R. \n
-   **'plotly'**: Used for creating interactive plots. It leverages D3.js for high-quality, interactive, web-based data visualizations.
-   **'RColorBrewer'**: Offers color palettes for enhancing the visual aesthetics of plots.

```{r loading libraries, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny) #for the interactive application
library(plotly) #for interactive plots
library(RColorBrewer)  # For using a nice color palette
```

Below are some important aspects of this project:

## The Collatz function

The base of the code and hence the data set for visualization was made out of this code. This function generates the Collatz sequence starting from a positive integer. If the current number in the sequence is even, it is halved; if odd, it is transformed according to the formula 3n + 1. The sequence continues until it reaches 1.

Code for the same is as follows:

```{r Collatz Function, echo=TRUE}
knitr::opts_chunk$set(echo = TRUE)
collatz <- function(n) {
  if (n <= 0 || n%%1 != 0) {
    stop("Please enter a positive integer.")
  }
  
  sequence <- n
  iterations <- 0
  while (n != 1) {
    iterations <- iterations + 1
    n <- ifelse(n %% 2 == 0, n / 2, 3 * n + 1)
    sequence <- c(sequence, n)
  }
  
  return(list(Sequence = sequence, Iterations = iterations))
}
```

```{r identify peaks, include=FALSE}
# Function to identify peaks in a sequence
identify_peaks <- function(sequence) {
  peaks <- which(diff(sign(diff(c(-Inf, sequence, -Inf)))) == -2)
  return(peaks)
}
```

## The multiplier function

The multiplier function is a complex function designed to explore and visualize the behavior of Collatz sequences when applied iteratively with a multiplier to the starting number. Below, is a detailed breakdown of how the function works, including how specific libraries and R packages are utilized throughout its operations:

### Function Overview

Purpose: To generate and analyze multiple Collatz sequences starting from an initial value n, increasing by a factor of m in each iteration, until a specific condition is met (a decrease in the p-value from the Shapiro-Wilk test of normality). It visualizes both the sequence and the normality assessment through interactive plots.

### Step-by-Step Explanation of the multiplier Function

#### Initialization:

1.  current_n is initialized with the user-supplied starting value n.
2.  previous_p is set to 0, serving as a baseline for the first iteration's p-value comparison.
3.  Data frames qq_data_all and seq_data_all are initialized to store the results from all iterations for final plotting.

#### Loop Execution:

The function enters a loop that continues until the stopping condition (a decrease in the Shapiro-Wilk test p-value) is met. Within each iteration, the collatz function is called with current_n to generate a Collatz sequence and count iterations.

#### Peak Identification:

To observe different trends in the collatz sequence of numbers, mathematicians have been studying various aspects of plots some of which include the number of iterations, number of peaks, max peak and many more. We have included these in the sequence plots further for your visualization. This function in particular is used to identify peaks which are then visualised in the multiplier function.

#### Statistical Testing for Normality:

1.  The Shapiro-Wilk test (shapiro.test) is performed on the sequence to evaluate its normality.
2.  The test's p-value (current_p) is compared with previous_p to decide whether to continue or stop the iterations.

#### Quantile-Quantile Data Preparation:

Sample quantiles of the sequence are calculated and matched against theoretical normal quantiles derived from the normal distribution with the same mean and standard deviation as the sequence. This step prepares the data for Q-Q plot visualization, which helps in assessing how closely the sequence data matches a normal distribution.

#### Plotting with plotly and RColorBrewer:

1.  **Sequence Plots**: Using plotly, the function dynamically plots each sequence iteration. Peaks are highlighted to draw attention to specific features of the sequences.
2.  **Q-Q Plots**: Similarly, using plotly, the function creates interactive Q-Q plots for each iteration. These plots show how well the sequence data fits a theoretical normal distribution.
3.  **Role of RColorBrewer**: This package provides a palette for coloring the plots, making distinctions between different iterations clearer and the plots more visually appealing.

#### Loop Control and Termination:

If current_p is less than previous_p, indicating that the sequence normality is worsening, the loop stops, and a message is printed. current_n is updated by multiplying it with m for the next iteration.

#### Final Plot Preparation and Output:

Both sequence and Q-Q plots are compiled from the collected data frames. The function adjusts plot aesthetics and ensures that the plots are ready to be displayed in the Shiny application.

#### Returned Plots

1.  **Combined Sequence Plot**: This plot shows all the sequences generated during the loop, with different colors for different sequences and special markers for peaks.
2.  **Combined Q-Q Plot**: Displays all the Q-Q plots for assessing normality across all iterations, with lines indicating the expected fit if the data were normally distributed.

Code for the same is as follows:

```{r The multiplier function, echo=TRUE}
multiplier <- function(n, m) {
  current_n <- n
  previous_p <- 0  # Initialize with zero to ensure first iteration always runs
  qq_data_all <- data.frame()  # Collect all Q-Q data
  seq_data_all <- list()  # Store all sequence data for combined plotting
  
  repeat {
    result <- collatz(current_n)
    sequence <- result$Sequence
    iterations <- result$Iterations
    peaks <- identify_peaks(sequence)
    max_peak_value <- max(sequence[peaks])  # Get the maximum peak value
    
    # Collect sequence data for plotting
    seq_df <- data.frame(Iteration = 0:iterations, Value = sequence, Group = paste("n =", current_n))
    seq_data_all[[paste("n =", current_n)]] <- seq_df
    
    # Shapiro-Wilk test for normality
    shapiro_test <- shapiro.test(sequence)
    current_p <- shapiro_test$p.value
    
    # Calculate and collect Q-Q data
    sample_quantiles <- quantile(sequence, probs = seq(0, 1, length.out = 100))
    theoretical_quantiles <- qnorm(seq(0, 1, length.out = 100), mean = mean(sequence), sd = sd(sequence))
    qq_data <- data.frame(Theoretical = theoretical_quantiles, Sample = sample_quantiles, Group = paste("n =", current_n, ", p-value:", format(current_p, digits=3)))
    qq_data_all <- rbind(qq_data_all, qq_data)
    
    # Print current state
    print(paste("n:", current_n, "Shapiro-Wilk p-value:", current_p, ", Peaks:", length(peaks), ", Max Peak Value:", max_peak_value))
    
    # Check if the p-value decreases
    if (current_p < previous_p) {
      cat("Stopping: p-value decreased.\n")
      break
    }
    
    previous_p <- current_p
    current_n <- current_n * m
  }
  
  # Extract 'n' values and check for issues
  qq_data_all$N_values <- sapply(strsplit(qq_data_all$Group, ","), function(x) as.numeric(gsub("\\D", "", x[1])))
  qq_data_all <- qq_data_all[order(qq_data_all$N_values),]
  qq_data_all$Group <- factor(qq_data_all$Group, levels = unique(qq_data_all$Group))
  
  # Initialize the color palette
  color_palette <- RColorBrewer::brewer.pal(8, "Dark2")
  
  # Plot combined sequence plot with peak highlights
  plot_sequence_combined <- plot_ly() %>%
    layout(title = "Combined Sequence Plots for All Iterations",
           xaxis = list(title = "Iteration Number"), yaxis = list(title = "Value"))
  
  seq_index <- 1  # Initialize the color index
  for (seq in seq_data_all) {
    peaks <- identify_peaks(seq$Value)
    max_peak_value <- max(seq$Value[peaks])
    number_of_iterations <- nrow(seq) - 1
    plot_sequence_combined <- add_trace(plot_sequence_combined, data = seq, x = ~Iteration, y = ~Value, type = 'scatter', mode = 'lines+markers',
                                        name = paste(unique(seq$Group), ", Iterations:",                 number_of_iterations), 
                                        line = list(color = color_palette[seq_index], width = 2),
                                        marker = list(size = 5, color = color_palette[seq_index]))
    plot_sequence_combined <- add_trace(plot_sequence_combined, data = seq[peaks,], x = ~Iteration, y = ~Value, type = 'scatter', mode = 'markers',
                                        name = paste("Max Peak:", max_peak_value, ", Peaks:", length(peaks)), marker = list(size = 10, color =  color_palette[seq_index], symbol = "triangle-up"), showlegend = TRUE)
    seq_index <- seq_index %% length(color_palette) + 1
  }
  
  # Plot combined Q-Q plot with reference line
  plot_qq_combined <- plot_ly(data = qq_data_all, x = ~Theoretical, y = ~Sample, color = ~Group, colors = "Blues",
                              type = 'scatter', mode = 'lines+markers') %>%
    layout(title = "Combined Q-Q Plot for All Iterations",
           xaxis = list(title = "Theoretical Quantiles"), yaxis = list(title = "Sample Quantiles"),
           showlegend = TRUE) %>%
    add_trace(x = ~Theoretical, y = ~Theoretical, type = 'scatter', mode = 'lines',
              line = list(color = 'grey', width = 2, dash = 'dash'), showlegend = FALSE)
  
  # Print combined plots
  print(plot_sequence_combined)
  print(plot_qq_combined)
  
  return(list(plot_sequence_combined = plot_sequence_combined, plot_qq_combined = plot_qq_combined))
}

```

## Creating an Interactive Application

Rather than running the code for just a few numbers we have created an application which provides the user with an open choice of selecting their initiators and multiplier for generations of plots.

We used the shiny library which provides us with functions such as fluidPage, titlePanel, sidebarPanel, and mainPanel with in the user interface, hence helps us to construct a responsive and well-structured layout. Widgets like numericInput and actionButton are crucial for gathering user inputs and triggering computations.

Whereas in the server function, Shiny's reactive programming model is utilized. reactiveValues stores plot data, allowing for dynamic updates. The observeEvent function listens for user actions (e.g., button clicks) to trigger plot generation.

### Defining the UI for the application

This is the code for the user interface that takes n (initiator) and m (multiplier) as inputs and generates the sequence and QQ plots for visualization.

```{r Defining the UI}
ui <- fluidPage(

    # Application title
    titlePanel("Dynamic Collatz Sequences and Q-Q Plots"),

    sidebarLayout(
      sidebarPanel(
        numericInput("startValue", "Enter starting value (n>2):", value = 9, min = 3),
        numericInput("multiplier", "Enter multiplier (m>1):", value = 2, min = 2),
        actionButton("goButton", "Generate Plots")
      ),
      mainPanel(
        tabsetPanel(
          tabPanel("Collatz Sequence Plot", plotlyOutput("plot_sequence_combined"),
                   downloadButton("download_sequence", "Download Sequence Plot")),
          tabPanel("Q-Q Plot", plotlyOutput("plot_qq_combined"),  
                   downloadButton("download_qq", "Download Q-Q Plot"))
        )
      )
    )
)
```

### Defining the server logic

This code gives the definition of the server logic required to draw the sequence and qq plots. We first define the reactive values for storing plots which are then further used in download handlers to export the plots

Code for the same is as follows:

```{r defining server logic, echo=TRUE}
server <- function(input, output) {
  
  # Define reactive values for storing plots
  reactive_plots <- reactiveValues(sequence = NULL, qq = NULL)
  
    observeEvent(input$goButton, {
    n <- input$startValue
    m <- input$multiplier
    
    # Generate plots
    plots <- multiplier(n, m)
    
    # Store plots in reactive values to use them in download handlers
    reactive_plots$sequence <- plots$plot_sequence_combined
    reactive_plots$qq <- plots$plot_qq_combined
    
    output$plot_sequence_combined <- renderPlotly({
      reactive_plots$sequence
    })
    
    output$plot_qq_combined <- renderPlotly({
      reactive_plots$qq
    })
  })
  
  # Download handlers
    output$download_sequence <- downloadHandler(
      filename = function() {
        paste("sequence-plot-", Sys.Date(), ".png", sep="")
      },
      content = function(file) {
        plotly::export(reactive_plots$sequence, file = file)
      }
    )
    
    output$download_qq <- downloadHandler(
      filename = function() {
        paste("qq-plot-", Sys.Date(), ".png", sep="")
      },
      content = function(file) {
        plotly::export(reactive_plots$qq, file = file)
      }
    )
    
}
```

### Running the Application

You can input any numbers here but make sure n\>2 and m\>1 or the code wont work.
Some Interesting examples could be (n=103, m=9);(n=107,10);(n=3,m=2). Finally lets try and run the application so click on generate plots and see what it can do...

```{r running the application, echo=FALSE, warning=TRUE}
shinyApp(ui = ui, server = server)

```

## Conclusion

This project has demonstrated the utility of interactive visualizations in exploring the complex behaviors of Collatz sequences through a web-based application. By implementing functions to dynamically generate and analyze these sequences with varying starting values and multipliers, the project provides users with insightful and accessible ways to explore mathematical phenomena.

From the investigations carried out, several conclusions can be drawn:

1. **Variability in Sequence Characteristics**: The initial value significantly impacts the characteristics of the Collatz sequence, such as its length and peak values. Higher initial values tend to produce longer sequences and higher peaks, though the behavior remains unpredictable and varies widely between even closely related starting numbers.  
2. **Impact of Multiplier on Normality**: Applying a multiplier to the starting number introduces a variation that affects the distribution of sequence values. The statistical tests and Q-Q plots used in the project suggest that the normality of these sequences can vary significantly depending on the multiplier applied. Generally, the sequences do not strictly follow a normal distribution, with the deviation becoming more pronounced as the multiplier increases.  
3. **Interactive Visualization as a Tool for Understanding**: The use of interactive tools like Shiny and Plotly has proven effective for real-time manipulation and visualization of data. This approach not only makes mathematical concepts more accessible but also allows for a deeper exploration of the underlying patterns and properties of the Collatz sequences.

All in all, the project underscores the unpredictability and complexity of the Collatz Conjecture and illustrates how interactive computational tools can enhance our understanding of such mathematical challenges. Moving forward, further refinement of the computational methods and enhancement of the user interface could provide even greater insights and a better user experience.

## Limitations:
Every project, program, application and code has its limitation ours is no different. The issues and possible improvements for this project are as follows:

#### **Performance with Large Numbers**:

**Issue**: The Collatz sequence computation may become computationally intensive as the starting value n increases, potentially leading to slower response times or even timeouts in a web-based application environment.    
**Improvement**: Implementing more efficient computation methods or algorithms, and potentially offloading heavy computations to server-side processes that can handle asynchronous execution.

#### **User Interface Simplicity**:

**Issue**: The current UI is quite basic and may not provide the best user experience for exploring and analyzing the sequences and statistical properties visually.  
**Improvement**: Enhance the UI with more interactive elements such as sliders for real-time parameter adjustment, better visualization controls, and more detailed tooltips or data point information on hover.

#### **Scalability**:

**Issue**: Shiny applications can suffer from scalability issues, especially if many users access the app simultaneously.  
**Improvement**: Use Shiny Server Pro or ShinyApps.io for better handling of multiple simultaneous users, or refactor the app to manage resources better.

#### **Error Handling and User Inputs**:

**Issue**: The app might not handle unexpected user inputs or errors gracefully beyond the basic validation shown.  
**Improvement**: Implement more robust error handling and input validation to prevent the application from crashing and to provide users with clearer error messages.

#### **Statistical Analysis Depth**:

**Issue**: The application currently performs a basic Shapiro-Wilk test for normality on the sequences but does not explore other statistical analyses that could provide deeper insights.  
**Improvement**: Incorporate additional statistical tests and analysis features, such as time-series analysis, trend identification, or even predictive modeling based on sequence characteristics.

#### **Deprecation of plotly::export**:
**Issue**: The code uses the 'plotly::export' function for downloading plots, which has been deprecated in favor of using orca for exporting Plotly graphs.  
**Improvement**: The application needs an update to replace deprecated functions with current recommended practices to ensure compatibility and functionality in future versions of the libraries. 

**I hope this project turns out to be useful for future mathematicians and could add to the scientific community as a base line for future research.**        
**Who knows someday we might solve this yet unsolvable problem.**
